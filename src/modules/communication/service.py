import json
import base64
import logging
from datetime import datetime

from .schemas import AudioContent, Message, MessageType, AudioStatus, Source
from src.modules.ai.service import AIService

logger = logging.getLogger(__name__)

class CommunicationService:
    def __init__(self):
        self.ws = None

        self.ai = AI()  # Config is loaded internally
        self.stt = STTClient(on_transcript=self.on_transcript)
        self.tts = TTSClient(on_speach=self.on_speach)  # Assumes TTSClient handles voice config internally

        logger.debug("CommunicationService initialized.")

    def register_websocket(self, websocket):
        self.ws = websocket

    async def process_client_message(self, raw_message):
        if not self.ws:
            logger.warning("No WebSocket registered.")
            return

        try:
            data = json.loads(raw_message)
            msg = Message.model_validate(data)
            content = msg.content

            # Delegate audio status handling to AIService
            if msg.type == MessageType.AUDIO and msg.source == Source.CLIENT:
                await self.ai.handle_audio_status(content)
        except Exception as e:
            await self.ws.send(f"Error processing message: {e}")
            logger.error(f"Error processing message: {e}", exc_info=True)

    async def on_transcript(self, text):
        if not self.ws:
            logger.warning("No output WebSocket registered.")
            return

        try:
            ai_response = self.ai.user_input(text)
            if not ai_response:
                logger.info("No response generated by AI.")
                return
            logger.info(f"AI response: {ai_response}")
            await self.tts.speak(ai_response)
        except Exception as e:
            logger.error(f"WebSocket send error: {e}", exc_info=True)

    async def on_speach(self, audio_data):
        if not self.ws:
            logger.warning("No output WebSocket registered.")
            return

        try:
            audio_bytes = audio_data.audio_int16_bytes
            chunk_size = 4096
            for i in range(0, len(audio_bytes), chunk_size):
                chunk = audio_bytes[i:i + chunk_size]
                audio_base64 = base64.b64encode(chunk).decode('utf-8')

                response = Message(
                    source=Source.SERVER,
                    type=MessageType.AUDIO,
                    source_id=None,
                    target_id=None,
                    timestamp=datetime.now().isoformat(),
                    content=AudioContent(
                        status=AudioStatus.SPEAKING,
                        audio=audio_base64
                    )
                )

                if Message.model_validate(response):
                    debug_msg = response.model_dump()
                    debug_msg["content"]["audio"] = debug_msg["content"]["audio"][:10] + "..."
                    logger.debug(f"Sending TTS audio chunk {i//chunk_size + 1}: " + str(debug_msg))
                    await self.ws.send(response.model_dump_json())
                    logger.debug(f"Successfully sent audio chunk {i//chunk_size + 1}")
                else:
                    logger.error("Invalid message schema.")
        except Exception as e:
            logger.error(f"WebSocket send error: {e}", exc_info=True)

communication_service = CommunicationService()
